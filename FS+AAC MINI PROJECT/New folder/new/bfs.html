<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BFS — Stepwise Visualizer</title>
  <style>
    :root{
      --topnav-height:56px;
      --sidenav-width:220px;
      --bg:#f6f7fb;
      --accent:#ff8c00;
      --visited:#b7e4c7;
      --queued:#9ec5fe;
      --skipped:#e0e0e0;
      --node-size:44px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;
      background:var(--bg);
      color:#111;
      height:100vh;
    }

    /* Top Navigation */
    .topnav{
      position:fixed;left:0;right:0;top:0;height:var(--topnav-height);
      background:#222;color:#fff;display:flex;align-items:center;gap:12px;padding:0 18px;z-index:1200
    }
    .topnav a{color:#fff;text-decoration:none;padding:10px 12px;border-radius:6px}
    .topnav a:hover{background:#2f2f2f}

    /* Right fixed sidenav */
    .sidenav{
      position:fixed;right:0;top:var(--topnav-height);bottom:0;width:var(--sidenav-width);
      background:#fff;border-left:1px solid #e3e6ef;padding:18px;overflow:auto;z-index:1100
    }
    .sidenav h4{margin:6px 0 10px}
    .sidenav .navlink{display:block;padding:10px;border-radius:6px;color:#222;text-decoration:none;margin-bottom:6px}
    .sidenav .navlink:hover{background:#f1f6ff}

    /* Main content area */
    .main{
      margin-top:var(--topnav-height);
      margin-right:calc(var(--sidenav-width) + 20px);
      padding:18px;min-height:calc(100vh - var(--topnav-height));
    }

    .layout{
      display:grid;grid-template-columns:320px 1fr;gap:18px;align-items:start;
    }

    /* Left column (controls & state) */
    .panel{background:#fff;border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(20,24,50,0.06)}
    .panel h3{margin:4px 0 10px}

    .pseudocode{font-family:monospace;background:#0f1724;color:#e6eef8;padding:10px;border-radius:8px}
    .pseudocode .line{padding:6px 8px;border-radius:6px}
    .pseudocode .highlight{background:#18304a}

    .state-box{display:flex;flex-direction:column;gap:8px}
    .state-box .box{background:#fbfdff;border:1px solid #e9eefb;padding:8px;border-radius:8px}

    .queue-list{display:flex;gap:8px;flex-wrap:wrap}
    .queue-item{padding:6px 10px;border-radius:8px;background:#fff;border:1px solid #d9e7ff;min-width:36px;text-align:center}

    /* Graph area */
    .graph-area{background:linear-gradient(180deg,#ffffff,#fbfdff);height:620px;border-radius:10px;padding:12px;position:relative;overflow:hidden}
    .svg-layer{position:absolute;left:0;right:0;top:0;bottom:0}

    .node{
      position:absolute;width:var(--node-size);height:var(--node-size);border-radius:50%;display:flex;align-items:center;justify-content:center;
      background:#fff;border:2px solid #2b2b2b;font-weight:600;transform:translate(-50%,-50%);box-shadow:0 4px 10px rgba(15,20,40,0.06);
    }
    .node.visited{background:var(--visited);border-color:#2d6a4f}
    .node.current{background:var(--accent);color:#fff;border-color:var(--accent)}
    .node.queued{background:var(--queued);border-color:#2b66d6}
    .node.skipped{background:var(--skipped);border-color:#9e9e9e}

    .legend{display:flex;gap:8px;align-items:center;margin-top:8px}
    .legend .item{display:flex;gap:6px;align-items:center}
    .legend .sw{width:18px;height:18px;border-radius:4px;border:1px solid #ccc}

    /* small labels */
    .small{font-size:13px;color:#555}

    /* controls */
    .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
    .btn{background:#0f1724;color:#fff;padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
    .btn.secondary{background:#fff;color:#0f1724;border:1px solid #d6dae6}
    .btn:disabled{opacity:0.5;cursor:not-allowed}

    /* adjacency & apps */
    .adj-list{display:flex;gap:8px;flex-wrap:wrap}
    .adj-item{padding:8px;border-radius:8px;background:#fff;border:1px solid #e6eefb}

    /* Responsive small screens */
    @media (max-width:1000px){
      .layout{grid-template-columns:1fr}
      .main{margin-right:0}
      .sidenav{position:static;width:100%;height:auto;border-left:none;border-top:1px solid #eee}
    }
  </style>
</head>
<body>
  <div class="topnav">
    <a href="index.html">Home</a>
    <a href="bfs.html">BFS</a>
    <a href="dfs.html">DFS</a>
    <div style="flex:1"></div>
    <div class="small">BFS Stepwise Visualizer</div>
  </div>

  <div class="sidenav">
    <h4>Sections</h4>
    <a class="navlink" href="#" onclick="showSection('about')">What is BFS?</a>
    <a class="navlink" href="#" onclick="showSection('visual')">Visualize It</a>
    <a class="navlink" href="#" onclick="showSection('apps')">Applications</a>
    <hr style="margin:12px 0">
    <div class="small">Tips</div>
    <div class="small" style="margin-top:8px">Use the play / next buttons to step through the algorithm. The panels show the queue, visited set and adjacency details for the current step.</div>
  </div>

  <main class="main">
    <div id="about" class="section">
      <h2>What is BFS?</h2>
      <p>Breadth-first search (BFS) is a graph traversal algorithm that explores vertices in order of their distance from the start vertex (level by level). It uses a <strong>queue</strong> to keep the frontier. This visualizer shows the graph and the queue/visited data-structures step-by-step so the user can see which elements are enqueued, dequeued and visited.</p>
    </div>

    <div id="visual" class="section" style="display:none">
      <div class="layout">
        <!-- Left column: state & controls -->
        <div>
          <div class="panel">
            <h3>Controls</h3>
            <div class="controls">
              <button id="prevBtn" class="btn secondary" onclick="prevStep()">◀ Prev</button>
              <button id="playBtn" class="btn" onclick="play()">▶ Play</button>
              <button id="pauseBtn" class="btn secondary" onclick="pause()" disabled>❚❚ Pause</button>
              <button id="nextBtn" class="btn secondary" onclick="nextStep()">Next ▶</button>
              <button id="resetBtn" class="btn secondary" onclick="resetAll()">↺ Reset</button>
            </div>

            <div style="margin-top:10px">
              <label class="small">Speed (ms per step)</label>
              <input id="speedRange" type="range" min="200" max="2000" step="100" value="900" oninput="speedLabel.innerText=this.value+'ms'">
              <div id="speedLabel" class="small">900ms</div>
            </div>

            <hr style="margin:12px 0">

            <div class="pseudocode">
              <div id="line1" class="line">1. enqueue(start)</div>
              <div id="line2" class="line">2. while (queue not empty) do</div>
              <div id="line3" class="line">3. &nbsp;&nbsp; node = dequeue()</div>
              <div id="line4" class="line">4. &nbsp;&nbsp; if (not visited(node)) then</div>
              <div id="line5" class="line">5. &nbsp;&nbsp;&nbsp;&nbsp; mark visited(node)</div>
              <div id="line6" class="line">6. &nbsp;&nbsp;&nbsp;&nbsp; for neighbor in adj[node]</div>
              <div id="line7" class="line">7. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (not visited(neighbor) and neighbor not in queue)</div>
              <div id="line8" class="line">8. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enqueue(neighbor)</div>
            </div>

          </div>

          <div class="panel" style="margin-top:12px">
            <h3>Queue</h3>
            <div class="box small state-box">
              <div class="small">Front -> Rear</div>
              <div id="queueDisplay" class="queue-list"></div>
            </div>

            <h3 style="margin-top:10px">Visited</h3>
            <div id="visitedDisplay" class="box small">[]</div>

            <h3 style="margin-top:10px">Adjacency (current)</h3>
            <div id="adjDisplay" class="adj-list"></div>

            <div style="margin-top:10px" class="legend">
              <div class="item"><span class="sw" style="background:var(--accent)"></span><span class="small">current</span></div>
              <div class="item"><span class="sw" style="background:var(--visited)"></span><span class="small">visited</span></div>
              <div class="item"><span class="sw" style="background:var(--queued)"></span><span class="small">in queue</span></div>
              <div class="item"><span class="sw" style="background:var(--skipped)"></span><span class="small">skipped</span></div>
            </div>

          </div>
        </div>

        <!-- Right column: graph -->
        <div>
          <div class="panel graph-area" id="graphPanel">
            <svg class="svg-layer" id="svgLayer" width="100%" height="100%" viewBox="0 0 900 620" preserveAspectRatio="xMidYMid meet"></svg>
            <!-- nodes will be injected here -->
          </div>
        </div>
      </div>
    </div>

    <div id="apps" class="section" style="display:none">
      <div class="panel">
        <h2>Applications of BFS</h2>
        <ul>
          <li>Shortest path in unweighted graphs</li>
          <li>Finding connected components (level-by-level)</li>
          <li>Peer to peer networks, Broadcasting</li>
          <li>Web crawlers, Social network friend suggestions</li>
        </ul>
        <div style="margin-top:12px"><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQcn8_YjNXiELaWDXwLmLg.png" alt="BFS image" style="max-width:100%;border-radius:8px"></div>
      </div>
    </div>

  </main>

  <script>
    // --- Graph definition (10 nodes) ---
    const GRAPH = {
      1: [2,3],
      2: [4,5],
      3: [6,7],
      4: [8,9],
      5: [],
      6: [],
      7: [],
      8: [],
      9: [10],
      10: []
    };

    // positions inside SVG viewBox 900 x 620
    const POS = {
      1: {x:450,y:80},
      2: {x:300,y:170},
      3: {x:600,y:170},
      4: {x:210,y:270},
      5: {x:360,y:270},
      6: {x:520,y:270},
      7: {x:700,y:270},
      8: {x:150,y:370},
      9: {x:260,y:370},
      10:{x:320,y:470}
    };

    // UI state
    let steps = [];
    let stepIndex = 0;
    let timer = null;

    // Build steps for BFS with rich snapshots
    function buildSteps(graph, start=1){
      const s = [];
      const visited = new Set();
      const queue = [start];

      s.push({type:'init', queue: queue.slice()});

      while(queue.length > 0){
        const queueBefore = queue.slice();
        const node = queue.shift();
        const queueAfter = queue.slice();

        s.push({type:'dequeue', node, queueBefore: queueBefore.slice(), queueAfter: queueAfter.slice()});

        if(!visited.has(node)){
          const visitedBefore = Array.from(visited);
          visited.add(node);
          const visitedAfter = Array.from(visited);
          s.push({type:'visit', node, visitedBefore, visitedAfter});

          // adjacency snapshot
          const neighbors = (graph[node]||[]).slice();
          s.push({type:'adjacency', node, neighbors});

          // for each neighbor, enqueue or skip
          for(const neigh of neighbors){
            const qBefore = queue.slice();
            if(!visited.has(neigh) && !queue.includes(neigh)){
              queue.push(neigh);
              const qAfter = queue.slice();
              s.push({type:'enqueue', from: node, neighbor: neigh, queueBefore: qBefore.slice(), queueAfter: qAfter.slice()});
            } else {
              const qAfter = queue.slice();
              const reason = visited.has(neigh) ? 'visited' : 'in-queue';
              s.push({type:'skip', from: node, neighbor: neigh, reason, queueBefore: qBefore.slice(), queueAfter: qAfter.slice()});
            }
          }
        }
      }

      s.push({type:'end'});
      return s;
    }

    // create visuals: svg edges + node elements
    function initGraph(){
      const svg = document.getElementById('svgLayer');
      svg.innerHTML = '';
      // edges
      for(const u in GRAPH){
        (GRAPH[u]||[]).forEach(v=>{
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', POS[u].x);
          line.setAttribute('y1', POS[u].y);
          line.setAttribute('x2', POS[v].x);
          line.setAttribute('y2', POS[v].y);
          line.setAttribute('stroke','#bbd5ff');
          line.setAttribute('stroke-width','3');
          line.setAttribute('marker-end','url(#arrow)');
          svg.appendChild(line);
        });
      }

      // defs for arrow
      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
      marker.setAttribute('id','arrow');marker.setAttribute('markerWidth','6');marker.setAttribute('markerHeight','6');marker.setAttribute('refX','6');marker.setAttribute('refY','3');marker.setAttribute('orient','auto');
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d','M0,0 L6,3 L0,6 L2,3 z');path.setAttribute('fill','#bbd5ff');
      marker.appendChild(path);defs.appendChild(marker);svg.appendChild(defs);

      // nodes (as HTML overlay)
      // remove old nodes
      const graphPanel = document.getElementById('graphPanel');
      // remove any existing node elements
      Array.from(graphPanel.querySelectorAll('.node')).forEach(n=>n.remove());

      for(const id in POS){
        const el = document.createElement('div');
        el.className = 'node';
        el.id = 'node' + id;
        el.style.left = POS[id].x + 'px';
        el.style.top = POS[id].y + 'px';
        el.innerText = id;
        graphPanel.appendChild(el);
      }
    }

    // Reconstruct state up to given step index
    function reconstructState(idx){
      let visited = new Set();
      let queue = [];
      let current = null;

      for(let i=0;i<=idx && i<steps.length;i++){
        const s = steps[i];
        if(!s) continue;
        switch(s.type){
          case 'init': queue = s.queue.slice(); break;
          case 'dequeue': current = s.node; queue = s.queueAfter.slice(); break;
          case 'visit': visited = new Set(s.visitedAfter); current = s.node; break;
          case 'adjacency': current = s.node; break;
          case 'enqueue': queue = s.queueAfter.slice(); current = s.from; break;
          case 'skip': queue = s.queueAfter.slice(); current = s.from; break;
          case 'end': break;
        }
      }
      return {queue, visited: Array.from(visited), current};
    }

    // look ahead to find neighbors enqueued or skipped for a specific node starting from step idx
    function lookAheadForNode(node, idx){
      const willEnqueue = [];
      const skipped = [];
      for(let i=idx;i<steps.length;i++){
        const s = steps[i];
        if(!s) continue;
        if((s.type==='enqueue' || s.type==='skip') && (s.from === node)){
          if(s.type==='enqueue') willEnqueue.push(s.neighbor);
          else skipped.push({neighbor:s.neighbor, reason:s.reason});
        }
        if(s.type==='dequeue' && s.node !== node) break; // we've moved to next node
      }
      return {willEnqueue, skipped};
    }

    // Render a particular step to the UI
    function renderStep(idx){
      const last = steps.length - 1;
      if(idx < 0) idx = 0;
      if(idx > last) idx = last;
      stepIndex = idx;

      // update play/pause button state
      document.getElementById('prevBtn').disabled = (idx===0);
      document.getElementById('nextBtn').disabled = (idx>=last);

      // highlight pseudocode lines
      ['line1','line2','line3','line4','line5','line6','line7','line8'].forEach(id=>document.getElementById(id).classList.remove('highlight'));

      const s = steps[idx];
      const state = reconstructState(idx);

      // default highlight: while loop
      document.getElementById('line2').classList.add('highlight');

      // clear node classes
      for(const id in POS){
        const el = document.getElementById('node'+id);
        el.classList.remove('visited','current','queued','skipped');
      }

      // set visited nodes
      state.visited.forEach(v=>{ const el = document.getElementById('node'+v); if(el) el.classList.add('visited'); });

      // set queued nodes
      state.queue.forEach(q=>{ const el = document.getElementById('node'+q); if(el && !state.visited.includes(q)) el.classList.add('queued'); });

      // set current node (if present)
      if(state.current){ const curEl = document.getElementById('node'+state.current); if(curEl) curEl.classList.add('current'); }

      // Update queue display
      const qDiv = document.getElementById('queueDisplay'); qDiv.innerHTML = '';
      state.queue.forEach(x=>{
        const el = document.createElement('div'); el.className='queue-item'; el.innerText = x; if(state.current===x) el.style.fontWeight='700'; qDiv.appendChild(el);
      });

      // visited display
      document.getElementById('visitedDisplay').innerText = '[' + state.visited.join(', ') + ']';

      // adjacency display
      const adjDiv = document.getElementById('adjDisplay'); adjDiv.innerHTML = '';
      let currentNode = state.current || (s && (s.node || s.from));
      if(currentNode){
        const neighbors = (GRAPH[currentNode]||[]).slice();
        const ahead = lookAheadForNode(currentNode, idx+1);
        neighbors.forEach(n=>{
          const e = document.createElement('div'); e.className='adj-item'; e.innerText = n;
          if(state.visited.includes(n)) { e.classList.add('small'); e.title='already visited'; e.style.opacity=0.7; }
          if(ahead.willEnqueue.includes(n)) { e.style.border='2px solid #2b66d6'; e.style.background='#eef6ff'; e.title='will be enqueued'; }
          const skipObj = ahead.skipped.find(x=>x.neighbor===n);
          if(skipObj){ e.style.opacity=0.6; e.title='skipped: '+skipObj.reason; }
          adjDiv.appendChild(e);
        });
      } else {
        adjDiv.innerHTML = '<div class="small">No current node</div>';
      }

      // Map current step type to pseudocode highlight
      if(s){
        switch(s.type){
          case 'init': document.getElementById('line1').classList.add('highlight'); break;
          case 'dequeue': document.getElementById('line3').classList.add('highlight'); break;
          case 'visit': document.getElementById('line5').classList.add('highlight'); break;
          case 'adjacency': document.getElementById('line6').classList.add('highlight'); break;
          case 'enqueue': document.getElementById('line7').classList.add('highlight'); document.getElementById('line8').classList.add('highlight'); break;
          case 'skip': document.getElementById('line7').classList.add('highlight'); break;
          case 'end': document.getElementById('line2').classList.remove('highlight'); document.getElementById('line1').classList.add('highlight'); break;
        }
      }

      // small status (disable/enable buttons handled above)
    }

    // Step controls
    function nextStep(){ if(stepIndex < steps.length-1){ renderStep(stepIndex+1); } else { pause(); } }
    function prevStep(){ if(stepIndex > 0) renderStep(stepIndex-1); }
    function resetAll(){ pause(); renderStep(0); }

    function play(){ document.getElementById('playBtn').disabled = true; document.getElementById('pauseBtn').disabled=false; const speed = parseInt(document.getElementById('speedRange').value,10); timer = setInterval(()=>{ if(stepIndex < steps.length-1){ nextStep(); } else { pause(); } }, speed); }
    function pause(){ document.getElementById('playBtn').disabled = false; document.getElementById('pauseBtn').disabled=true; if(timer){ clearInterval(timer); timer = null; } }

    // Section switching
    function showSection(id){ document.querySelectorAll('.section').forEach(el=>el.style.display='none'); document.getElementById(id).style.display='block'; if(id==='visual'){ // initialize visual area
        initGraph(); steps = buildSteps(GRAPH,1); renderStep(0);
      } }

    // init on load: show about
    document.addEventListener('DOMContentLoaded',()=>{
      showSection('about');
    });

    // expose functions to window
    window.nextStep = nextStep; window.prevStep = prevStep; window.play = play; window.pause = pause; window.resetAll = resetAll; window.showSection = showSection;
  </script>
</body>
</html>
